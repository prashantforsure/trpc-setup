import { getTRPCErrorFromUnknown } from '../../unstable-core-do-not-import/error/TRPCError.mjs';
import { resolveResponse } from '../../unstable-core-do-not-import/http/resolveResponse.mjs';
import '../../unstable-core-do-not-import/rootConfig.mjs';
import { incomingMessageToRequest } from './incomingMessageToRequest.mjs';

/**
 * If you're making an adapter for tRPC and looking at this file for reference, you should import types and functions from `@trpc/server` and `@trpc/server/http`
 *
 * @example
 * ```ts
 * import type { AnyTRPCRouter } from '@trpc/server'
 * import type { HTTPBaseHandlerOptions } from '@trpc/server/http'
 * ```
 */ // @trpc/server
async function nodeHTTPRequestHandler(opts) {
    const handleViaMiddleware = opts.middleware ?? ((_req, _res, next)=>next());
    return handleViaMiddleware(opts.req, opts.res, async (err)=>{
        const req = incomingMessageToRequest(opts.req, {
            maxBodySize: opts.maxBodySize ?? null
        });
        // Build tRPC dependencies
        const createContext = async (innerOpts)=>{
            return await opts.createContext?.({
                ...opts,
                ...innerOpts
            });
        };
        const response = await resolveResponse({
            ...opts,
            req,
            error: err ? getTRPCErrorFromUnknown(err) : null,
            createContext,
            onError (o) {
                opts?.onError?.({
                    ...o,
                    req: opts.req
                });
            }
        });
        const { res  } = opts;
        if (res.statusCode === 200) {
            // if the status code is set, we assume that it's been manually overridden
            res.statusCode = response.status;
        }
        for (const [key, value] of response.headers){
            res.setHeader(key, value);
        }
        if (response.body) {
            const reader = response.body.getReader();
            const onAbort = ()=>{
                // cancelling the reader will cause the whole stream to be cancelled
                reader.cancel().catch(()=>{
                // console.error('reader.cancel() error', err);
                });
            };
            req.signal.addEventListener('abort', onAbort, {
                once: true
            });
            while(true){
                const { done , value: value1  } = await reader.read();
                if (done) {
                    break;
                }
                if (!res.writable) {
                    break;
                }
                if (res.write(value1) === false) {
                    await new Promise((resolve)=>{
                        res.once('drain', resolve);
                    });
                }
                // useful for debugging chunked responses:
                // console.log('wrote', Buffer.from(value).toString());
                // IMPORTANT - flush the response buffer, otherwise the client will not receive the data until `.end()`
                res.flush?.();
            }
            req.signal.removeEventListener('abort', onAbort);
        }
        res.end();
    });
}

export { nodeHTTPRequestHandler };
