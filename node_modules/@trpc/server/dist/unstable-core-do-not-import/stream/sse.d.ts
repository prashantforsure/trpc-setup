import type { ConsumerOnError } from './jsonl';
import type { inferTrackedOutput } from './tracked';
type Serialize = (value: any) => any;
type Deserialize = (value: any) => any;
/**
 * @internal
 */
export interface PingOptions {
    /**
     * Enable ping comments sent from the server
     * @default false
     */
    enabled: boolean;
    /**
     * Interval in milliseconds
     * @default 1000
     */
    intervalMs?: number;
}
export interface SSEStreamProducerOptions {
    serialize?: Serialize;
    data: AsyncIterable<unknown>;
    maxDepth?: number;
    ping?: PingOptions;
    /**
     * Maximum duration in milliseconds for the request before ending the stream
     * Only useful for serverless runtimes
     * @default undefined
     */
    maxDurationMs?: number;
    /**
     * End the request immediately after data is sent
     * Only useful for serverless runtimes that do not support streaming responses
     * @default false
     */
    emitAndEndImmediately?: boolean;
    formatError?: (opts: {
        error: unknown;
    }) => unknown;
}
/**
 *
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */
export declare function sseStreamProducer(opts: SSEStreamProducerOptions): ReadableStream<string>;
type ConsumerStreamResult<TData> = {
    ok: true;
    data: inferTrackedOutput<TData>;
} | {
    ok: false;
    error: unknown;
};
/**
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */
export declare function sseStreamConsumer<TData>(opts: {
    from: EventSource;
    onError?: ConsumerOnError;
    deserialize?: Deserialize;
}): AsyncIterable<ConsumerStreamResult<TData>>;
export declare const sseHeaders: {
    readonly 'Content-Type': "text/event-stream";
    readonly 'Cache-Control': "no-cache, no-transform";
    readonly 'X-Accel-Buffering': "no";
    readonly Connection: "keep-alive";
};
export {};
//# sourceMappingURL=sse.d.ts.map