'use strict';

var observable = require('@trpc/server/observable');
var unstableCoreDoNotImport = require('@trpc/server/unstable-core-do-not-import');
var TRPCClientError = require('../TRPCClientError.js');
var transformer = require('../internals/transformer.js');
var httpUtils = require('./internals/httpUtils.js');
var urlWithConnectionParams$1 = require('./internals/urlWithConnectionParams.js');

async function urlWithConnectionParams(opts) {
    let url = await urlWithConnectionParams$1.resultOf(opts.url);
    if (opts.connectionParams) {
        const params = await urlWithConnectionParams$1.resultOf(opts.connectionParams);
        const prefix = url.includes('?') ? '&' : '?';
        url += prefix + 'connectionParams=' + encodeURIComponent(JSON.stringify(params));
    }
    return url;
}
/**
 * @see https://trpc.io/docs/client/links/httpSubscriptionLink
 */ function unstable_httpSubscriptionLink(opts) {
    const transformer$1 = transformer.getTransformer(opts.transformer);
    return ()=>{
        return ({ op  })=>{
            return observable.observable((observer)=>{
                const { type , path , input  } = op;
                /* istanbul ignore if -- @preserve */ if (type !== 'subscription') {
                    throw new Error('httpSubscriptionLink only supports subscriptions');
                }
                let eventSource = null;
                let unsubscribed = false;
                unstableCoreDoNotImport.run(async ()=>{
                    const url = httpUtils.getUrl({
                        transformer: transformer$1,
                        url: await urlWithConnectionParams(opts),
                        input,
                        path,
                        type,
                        signal: null
                    });
                    const eventSourceOptions = await urlWithConnectionParams$1.resultOf(opts.eventSourceOptions);
                    /* istanbul ignore if -- @preserve */ if (unsubscribed) {
                        // already unsubscribed - rare race condition
                        return;
                    }
                    eventSource = new EventSource(url, eventSourceOptions);
                    const onStarted = ()=>{
                        observer.next({
                            result: {
                                type: 'started'
                            },
                            context: {
                                eventSource
                            }
                        });
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        eventSource.removeEventListener('open', onStarted);
                    };
                    // console.log('starting', new Date());
                    eventSource.addEventListener('open', onStarted);
                    const iterable = unstableCoreDoNotImport.sseStreamConsumer({
                        from: eventSource,
                        deserialize: transformer$1.output.deserialize
                    });
                    for await (const chunk of iterable){
                        if (!chunk.ok) {
                            continue;
                        }
                        const chunkData = chunk.data;
                        // if the `tracked()`-helper is used, we always have an `id` field
                        const data = 'id' in chunkData ? chunkData : chunkData.data;
                        observer.next({
                            result: {
                                data
                            }
                        });
                    }
                    observer.next({
                        result: {
                            type: 'stopped'
                        }
                    });
                    observer.complete();
                }).catch((error)=>{
                    observer.error(TRPCClientError.TRPCClientError.from(error));
                });
                return ()=>{
                    observer.complete();
                    eventSource?.close();
                    unsubscribed = true;
                };
            });
        };
    };
}

exports.unstable_httpSubscriptionLink = unstable_httpSubscriptionLink;
